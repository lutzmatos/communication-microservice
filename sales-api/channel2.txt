<ref *2> Channel {
  _events: [Object: null prototype] {
    ack: [Function: bound ],
    nack: [Function: bound ],
    close: [Function (anonymous)],
    delivery: [Function: bound ],
    cancel: [Function: bound ]
  },
  _eventsCount: 5,
  _maxListeners: undefined,
  connection: Connection {
    _events: [Object: null prototype] {
      frameError: [Function: bound ],
      error: [Function: bound emit],
      close: [Function: bound emit],
      blocked: [Function: bound emit],
      unblocked: [Function: bound emit]
    },
    _eventsCount: 5,
    _maxListeners: undefined,
    stream: <ref *1> Socket {
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: null,
      _readableState: ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList {
          head: null,
          tail: null,
          length: 0
        },
        length: 0,
        pipes: [],
        flowing: false,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: true,
        resumeScheduled: false,
        errorEmitted: false,
        emitClose: false,
        autoDestroy: false,
        destroyed: false,
        errored: null,
        closed: false,
        closeEmitted: false,
        defaultEncoding: 'utf8',
        awaitDrainWriters: null,
        multiAwaitDrain: false,
        readingMore: false,
        dataEmitted: true,
        decoder: null,
        encoding: null,
        [Symbol(kPaused)]: null
      },
      _events: [Object: null prototype] {
        end: [
          [Function: onReadableStreamEnd],
          [Function: bound ]
        ],
        error: [
          [Function: bound onceWrapper] {
            listener: [Function (anonymous)]
          },
          [Function: bound ]
        ],
        drain: [Function (anonymous)],
        readable: [Function: go]
      },
      _eventsCount: 4,
      _maxListeners: undefined,
      _writableState: WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        afterWriteTickInfo: null,
        buffered: [],
        bufferedIndex: 0,
        allBuffers: true,
        allNoop: true,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        autoDestroy: false,
        errored: null,
        closed: false,
        closeEmitted: false,
        writable: true
      },
      allowHalfOpen: false,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: null,
      _server: null,
      [Symbol(async_id_symbol)]: 125,
      [Symbol(kHandle)]: TCP {
        reading: true,
        onconnection: null,
        [Symbol(owner_symbol)]: [Circular *1]
      },
      [Symbol(kSetNoDelay)]: false,
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: null,
      [Symbol(kBuffer)]: null,
      [Symbol(kBufferCb)]: null,
      [Symbol(kBufferGen)]: null,
      [Symbol(kCapture)]: false,
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0
    },
    muxer: Mux {
      newStreams: [],
      oldStreams: [],
      blocked: false,
      scheduledRead: false,
      out: <ref *1> Socket {
        connecting: false,
        _hadError: false,
        _parent: null,
        _host: null,
        _readableState: ReadableState {
          objectMode: false,
          highWaterMark: 16384,
          buffer: BufferList {
            head: null,
            tail: null,
            length: 0
          },
          length: 0,
          pipes: [],
          flowing: false,
          ended: false,
          endEmitted: false,
          reading: true,
          sync: false,
          needReadable: true,
          emittedReadable: false,
          readableListening: true,
          resumeScheduled: false,
          errorEmitted: false,
          emitClose: false,
          autoDestroy: false,
          destroyed: false,
          errored: null,
          closed: false,
          closeEmitted: false,
          defaultEncoding: 'utf8',
          awaitDrainWriters: null,
          multiAwaitDrain: false,
          readingMore: false,
          dataEmitted: true,
          decoder: null,
          encoding: null,
          [Symbol(kPaused)]: null
        },
        _events: [Object: null prototype] {
          end: [
            [Function: onReadableStreamEnd],
            [Function: bound ]
          ],
          error: [
            [Function: bound onceWrapper] {
              listener: [Function (anonymous)]
            },
            [Function: bound ]
          ],
          drain: [Function (anonymous)],
          readable: [Function: go]
        },
        _eventsCount: 4,
        _maxListeners: undefined,
        _writableState: WritableState {
          objectMode: false,
          highWaterMark: 16384,
          finalCalled: false,
          needDrain: false,
          ending: false,
          ended: false,
          finished: false,
          destroyed: false,
          decodeStrings: false,
          defaultEncoding: 'utf8',
          length: 0,
          writing: false,
          corked: 0,
          sync: false,
          bufferProcessing: false,
          onwrite: [Function: bound onwrite],
          writecb: null,
          writelen: 0,
          afterWriteTickInfo: null,
          buffered: [],
          bufferedIndex: 0,
          allBuffers: true,
          allNoop: true,
          pendingcb: 0,
          prefinished: false,
          errorEmitted: false,
          emitClose: false,
          autoDestroy: false,
          errored: null,
          closed: false,
          closeEmitted: false,
          writable: true
        },
        allowHalfOpen: false,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: null,
        _server: null,
        [Symbol(async_id_symbol)]: 125,
        [Symbol(kHandle)]: TCP {
          reading: true,
          onconnection: null,
          [Symbol(owner_symbol)]: [Circular *1]
        },
        [Symbol(kSetNoDelay)]: false,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: null,
        [Symbol(kBuffer)]: null,
        [Symbol(kBufferCb)]: null,
        [Symbol(kBufferGen)]: null,
        [Symbol(kCapture)]: false,
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0
      }
    },
    rest: <Buffer >,
    frameMax: 4096,
    sentSinceLastCheck: true,
    recvSinceLastCheck: true,
    expectSocketClose: false,
    freeChannels: BitSet {
      words: [
        2
      ],
      wordsInUse: 1
    },
    channels: [
      {
        channel: {
          accept: [Function (anonymous)]
        },
        buffer: <ref *1> Socket {
          connecting: false,
          _hadError: false,
          _parent: null,
          _host: null,
          _readableState: ReadableState {
            objectMode: false,
            highWaterMark: 16384,
            buffer: BufferList {
              head: null,
              tail: null,
              length: 0
            },
            length: 0,
            pipes: [],
            flowing: false,
            ended: false,
            endEmitted: false,
            reading: true,
            sync: false,
            needReadable: true,
            emittedReadable: false,
            readableListening: true,
            resumeScheduled: false,
            errorEmitted: false,
            emitClose: false,
            autoDestroy: false,
            destroyed: false,
            errored: null,
            closed: false,
            closeEmitted: false,
            defaultEncoding: 'utf8',
            awaitDrainWriters: null,
            multiAwaitDrain: false,
            readingMore: false,
            dataEmitted: true,
            decoder: null,
            encoding: null,
            [Symbol(kPaused)]: null
          },
          _events: [Object: null prototype] {
            end: [
              [Function: onReadableStreamEnd],
              [Function: bound ]
            ],
            error: [
              [Function: bound onceWrapper] {
                listener: [Function (anonymous)]
              },
              [Function: bound ]
            ],
            drain: [Function (anonymous)],
            readable: [Function: go]
          },
          _eventsCount: 4,
          _maxListeners: undefined,
          _writableState: WritableState {
            objectMode: false,
            highWaterMark: 16384,
            finalCalled: false,
            needDrain: false,
            ending: false,
            ended: false,
            finished: false,
            destroyed: false,
            decodeStrings: false,
            defaultEncoding: 'utf8',
            length: 0,
            writing: false,
            corked: 0,
            sync: false,
            bufferProcessing: false,
            onwrite: [Function: bound onwrite],
            writecb: null,
            writelen: 0,
            afterWriteTickInfo: null,
            buffered: [],
            bufferedIndex: 0,
            allBuffers: true,
            allNoop: true,
            pendingcb: 0,
            prefinished: false,
            errorEmitted: false,
            emitClose: false,
            autoDestroy: false,
            errored: null,
            closed: false,
            closeEmitted: false,
            writable: true
          },
          allowHalfOpen: false,
          _sockname: null,
          _pendingData: null,
          _pendingEncoding: '',
          server: null,
          _server: null,
          [Symbol(async_id_symbol)]: 125,
          [Symbol(kHandle)]: TCP {
            reading: true,
            onconnection: null,
            [Symbol(owner_symbol)]: [Circular *1]
          },
          [Symbol(kSetNoDelay)]: false,
          [Symbol(lastWriteQueueSize)]: 0,
          [Symbol(timeout)]: null,
          [Symbol(kBuffer)]: null,
          [Symbol(kBufferCb)]: null,
          [Symbol(kBufferGen)]: null,
          [Symbol(kCapture)]: false,
          [Symbol(kBytesRead)]: 0,
          [Symbol(kBytesWritten)]: 0
        }
      },
      {
        channel: [Circular *2],
        buffer: <ref *3> PassThrough {
          _readableState: ReadableState {
            objectMode: true,
            highWaterMark: 1024,
            buffer: BufferList {
              head: [Object],
              tail: [Object],
              length: 1
            },
            length: 1,
            pipes: [],
            flowing: false,
            ended: false,
            endEmitted: false,
            reading: false,
            sync: false,
            needReadable: false,
            emittedReadable: true,
            readableListening: true,
            resumeScheduled: false,
            errorEmitted: false,
            emitClose: true,
            autoDestroy: true,
            destroyed: false,
            errored: null,
            closed: false,
            closeEmitted: false,
            defaultEncoding: 'utf8',
            awaitDrainWriters: null,
            multiAwaitDrain: false,
            readingMore: true,
            dataEmitted: true,
            decoder: null,
            encoding: null,
            [Symbol(kPaused)]: null
          },
          _events: [Object: null prototype] {
            prefinish: [Function: prefinish],
            drain: [Function (anonymous)],
            unpipeFrom: [Function: cleanupIfMe],
            end: [Function: cleanup],
            error: [Function: cleanup],
            readable: [Function: enqueue]
          },
          _eventsCount: 6,
          _maxListeners: undefined,
          _writableState: <ref *4> WritableState {
            objectMode: true,
            highWaterMark: 1024,
            finalCalled: false,
            needDrain: false,
            ending: false,
            ended: false,
            finished: false,
            destroyed: false,
            decodeStrings: true,
            defaultEncoding: 'utf8',
            length: 0,
            writing: false,
            corked: 0,
            sync: false,
            bufferProcessing: false,
            onwrite: [Function: bound onwrite],
            writecb: null,
            writelen: 0,
            afterWriteTickInfo: {
              count: 1,
              cb: [Function: nop],
              stream: [Circular *3],
              state: [Circular *4]
            },
            buffered: [],
            bufferedIndex: 0,
            allBuffers: true,
            allNoop: true,
            pendingcb: 1,
            prefinished: false,
            errorEmitted: false,
            emitClose: true,
            autoDestroy: true,
            errored: null,
            closed: false
          },
          allowHalfOpen: true,
          [Symbol(kCapture)]: false,
          [Symbol(kTransformState)]: {
            afterTransform: [Function: bound afterTransform],
            needTransform: true,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: 'utf8'
          }
        }
      }
    ],
    serverProperties: {
      capabilities: {
        publisher_confirms: true,
        exchange_exchange_bindings: true,
        'basic.nack': true,
        consumer_cancel_notify: true,
        'connection.blocked': true,
        consumer_priorities: true,
        authentication_failure_close: true,
        per_consumer_qos: true,
        direct_reply_to: true
      },
      cluster_name: 'rabbit@rabbit-sales',
      copyright: 'Copyright (c) 2007-2022 VMware, Inc. or its affiliates.',
      information: 'Licensed under the MPL 2.0. Website: https://rabbitmq.com',
      platform: 'Erlang/OTP 24.3.4.2',
      product: 'RabbitMQ',
      version: '3.10.6'
    },
    channelMax: 2047,
    heartbeat: 60,
    heartbeater: Heart {
      _events: [Object: null prototype] {
        timeout: [Function (anonymous)],
        beat: [Function (anonymous)]
      },
      _eventsCount: 2,
      _maxListeners: undefined,
      interval: 60,
      sendTimer: Timeout {
        _idleTimeout: 30000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1360,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: 30000,
        _destroyed: false,
        [Symbol(refed)]: true,
        [Symbol(kHasPrimitive)]: false,
        [Symbol(asyncId)]: 163,
        [Symbol(triggerId)]: 160
      },
      recvTimer: Timeout {
        _idleTimeout: 60000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1360,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: 60000,
        _destroyed: false,
        [Symbol(refed)]: true,
        [Symbol(kHasPrimitive)]: false,
        [Symbol(asyncId)]: 164,
        [Symbol(triggerId)]: 160
      },
      [Symbol(kCapture)]: false
    },
    accept: [Function: mainAccept],
    [Symbol(kCapture)]: false
  },
  reply: null,
  pending: [],
  lwm: 1,
  unconfirmed: [],
  handleMessage: [Function: acceptDeliveryOrReturn],
  consumers: Map(0) {},
  ch: 1,
  sendMessage: [Function (anonymous)],
  sendOrEnqueue: [Function (anonymous)],
  sendImmediately: [Function (anonymous)],
  accept: [Function (anonymous)],
  [Symbol(kCapture)]: false
}